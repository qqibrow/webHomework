<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<HTML> 
<HEAD> 
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>Simple Javascript</TITLE> 
<style media="screen" type="text/css">

.center
{
	
	display:block;
	 margin-left: auto;
    margin-right: auto;
	text-align:center;
}


table, th, td
{
border: 1px solid black;
}
</style>
<script type="text/javascript">

function checkCustomerExist(xmlDoc)
{
	customers = xmlDoc.getElementsByTagName("Customer");
	if(customers.length == 0)
		return false;
	return true;
}
function getCustomerIDOforder(order)
{
	orderchild = first_child(order);
		while(orderchild)
		{
			if(orderchild.nodeName == 'CustomerID')
			{	
				return data_of(first_child(orderchild));
			}			
			orderchild = node_after(orderchild);
		}
	return null;
}

function ifCustomerIdExist(customerID, customerIDs)
{
	for(i = 0; i < customerIDs.length; i++)
	{
		if(customerIDs[i] == customerID)
			return true;
		
	}
	return false;
}

function getAllcustomerIDs(xmlDoc)
{
	var array = new Array();
	customers = xmlDoc.getElementsByTagName("Customer");
	for(i = 0; i < customers.length; i++)
	{
		array[i] = customers[i].getAttribute("CustomerID");	
	}
	return array;
}

function getAllOrderCustomers(xmlDoc)
{
	var array = new Array();
	orders = xmlDoc.getElementsByTagName("Order");
	for(i = 0; i < orders.length; i++)
	{
		array[i] = getCustomerIDOforder(orders[i]);
		
	}
	return array;
}


function checkOrderHasRelatedCustomer(xmlDoc)
{
	customerIDs = getAllcustomerIDs(xmlDoc);
	ordersCustomer = getAllOrderCustomers(xmlDoc);
	
	for( item in ordersCustomer)
	{
		if(ifCustomerIdExist(ordersCustomer[item], customerIDs) == false)
			return false;
		
	}
	return true;
}

var xmlDoc = null;
var passXmlFile = function(){

	if (document.implementation && 
	document.implementation.createDocument) 
	{ 
		xmlDoc = document.implementation.createDocument("","doc",null);   
		xmlDoc.async = false;   
		
		fileName = document.getElementById("xmlNameInput").value;
		
		loaded = xmlDoc.load(fileName); 
		if(!loaded){ 
		
			alert("Cannot find " + fileName); 
		} 
		else 
		{ 
			alert(fileName + " open succeed");
			
			if(!checkCustomerExist(xmlDoc))
			{
				alert(fileName + "has no customers");
				return;
			}
			
			if(!checkOrderHasRelatedCustomer(xmlDoc))
			{
				alert(fileName + "has order that no correspoding customer");
				return;
			}
			
			str = printTable(xmlDoc);
			document.getElementById("form").innerHTML = "";
			document.getElementById("content").innerHTML = str;
		}

		
	} 

}


function printOneOrder(order)
{
		str = '';
		y=order.childNodes;				
		for (j=0;j<y.length;j++)
		{
		   if (y[j].nodeType == 1 && y[j].nodeName != 'CustomerID' && y[j].nodeName != 'EmployeeID')
		   { 
			  if( y[j].nodeName == 'ShipInfo')
			  {
				shipInfo = y[j].getAttribute("ShippedDate");
				if(shipInfo == null)
					shipInfo = 'N/A'
				str = str + createBlock(shipInfo);
				shipInfochild = first_child(y[j]);
				while(shipInfochild)
				{				
					str = str + createBlock(data_of(first_child(shipInfochild)));
					shipInfochild = node_after(shipInfochild);
				}
			  }
			  else
				str = str + createBlock(y[j].childNodes[0].nodeValue);
			  
			  
		   }
		}
		
		return createRow(str);
}

function showRelatedOrdersByCustomerID(customerID)
{
	
	orders = xmlDoc.getElementsByTagName("Order");
	order = orders[0];
	str = '';
	str += '<table> <th> Order for Customer ' + customerID + '</th>';
	str += (createRow(createBlock("Order Date") +  createBlock("Required Date") + createBlock("ShipInfo") + createBlock("Ship Via") + createBlock("Freight") + createBlock("ShipName")+ createBlock("Ship Address")+ createBlock("Ship City")+ createBlock("Ship Region")+ createBlock("Ship Postal Chode")+ createBlock("Ship Country")));
	
	var i = 0;
	while(order)
	{
		//find whether the order's customer id is customerID	
		orderchild = first_child(order);
		while(orderchild)
		{
			if(orderchild.nodeName == 'CustomerID')
			{	
				if(data_of(first_child(orderchild)) == customerID)
				{
					str += printOneOrder(order);
					i++;
				}
					
				else
					break;
			}			
			orderchild = node_after(orderchild);
		}
		order = node_after(order);
	}
	str +=('</table>');
	
	if(i == 0)
	{
		alert(customerID + "has no orders");
		str = '';
	}
	
	return str;
}



function showCustomerOrder()
{

	var inputObjects = document.getElementsByTagName("input");
	for(var i = 0; i < inputObjects.length; i++)
	{
		var obj = inputObjects[i];
		if( obj.type == 'radio' && obj.checked == true)
		{
			customerID = obj.id;
			str = showRelatedOrdersByCustomerID(customerID);
			
			if(str != '')
			{
				document.getElementById("content").innerHTML = str;
				break;
			}
				
		}
	}
}


function createRow(foo)
{
	
	return '<tr>' + foo + '</tr>';


}

function createBlock(str)
{
	return '<td>' + str + '</td>';
}

function createTable(content)
{
	document.write('<table>' + content + '</table>');
}

var printTable = function(xmlDoc)
{	
	content = '';
	content += '<table> <th> List of Customer Information </th>';
	
	content += (createRow(createBlock("Select One Click Submit") +  createBlock("Customer ID") + createBlock("Company Name") + createBlock("Contact Name") + createBlock("Contact Title") + createBlock("Phone")));
	
	
	customer = xmlDoc.getElementsByTagName("Customer")[0];
	
	var customerArray = new Array();
	
	i = 0;
	while (customer)
	{
	
		radioTextLeft = '<INPUT TYPE="radio" name = "order" id ="';		
		radioTextRight = '">';		
		str = createBlock(radioTextLeft + customer.getAttribute("CustomerID") + radioTextRight);
		
		str = str + createBlock(customer.getAttribute("CustomerID"));
		customerArray[i] = customer.getAttribute("CustomerID");
		
		customerChild = first_child(customer);
		while(customerChild)
		{
			if(customerChild.nodeType == 1 && customerChild.nodeName != 'Fax')
			{
				node = customerChild.childNodes[0];
				if(!is_all_ws(node))
				str = str + createBlock(data_of(node));
			}
			customerChild = node_after(customerChild);
		}
		
		str = createRow(str);
		content +=(str);
		i++;
	  
	  
	  
	  customer = node_after(customer);
	 
	}
	
	content += '</table><input type="button" value="Submit" onClick = "showCustomerOrder()"/>';
	return content;
}

/////////////////below is the function from to handle with write space/////////////////////

/**
 * Throughout, whitespace is defined as one of the characters
 *  "\t" TAB \u0009
 *  "\n" LF  \u000A
 *  "\r" CR  \u000D
 *  " "  SPC \u0020
 *
 * This does not use Javascript's "\s" because that includes non-breaking
 * spaces (and also some other characters).
 */


/**
 * Determine whether a node's text content is entirely whitespace.
 *
 * @param nod  A node implementing the |CharacterData| interface (i.e.,
 *             a |Text|, |Comment|, or |CDATASection| node
 * @return     True if all of the text content of |nod| is whitespace,
 *             otherwise false.
 */
function is_all_ws( nod )
{
  // Use ECMA-262 Edition 3 String and RegExp features
  return !(/[^\t\n\r ]/.test(nod.data));
}


/**
 * Determine if a node should be ignored by the iterator functions.
 *
 * @param nod  An object implementing the DOM1 |Node| interface.
 * @return     true if the node is:
 *                1) A |Text| node that is all whitespace
 *                2) A |Comment| node
 *             and otherwise false.
 */

function is_ignorable( nod )
{
  return ( nod.nodeType == 8) || // A comment node
         ( (nod.nodeType == 3) && is_all_ws(nod) ); // a text node, all ws
}

/**
 * Version of |previousSibling| that skips nodes that are entirely
 * whitespace or comments.  (Normally |previousSibling| is a property
 * of all DOM nodes that gives the sibling node, the node that is
 * a child of the same parent, that occurs immediately before the
 * reference node.)
 *
 * @param sib  The reference node.
 * @return     Either:
 *               1) The closest previous sibling to |sib| that is not
 *                  ignorable according to |is_ignorable|, or
 *               2) null if no such node exists.
 */
function node_before( sib )
{
  while ((sib = sib.previousSibling)) {
    if (!is_ignorable(sib)) return sib;
  }
  return null;
}

/**
 * Version of |nextSibling| that skips nodes that are entirely
 * whitespace or comments.
 *
 * @param sib  The reference node.
 * @return     Either:
 *               1) The closest next sibling to |sib| that is not
 *                  ignorable according to |is_ignorable|, or
 *               2) null if no such node exists.
 */
function node_after( sib )
{
  while ((sib = sib.nextSibling)) {
    if (!is_ignorable(sib)) return sib;
  }
  return null;
}

/**
 * Version of |lastChild| that skips nodes that are entirely
 * whitespace or comments.  (Normally |lastChild| is a property
 * of all DOM nodes that gives the last of the nodes contained
 * directly in the reference node.)
 *
 * @param sib  The reference node.
 * @return     Either:
 *               1) The last child of |sib| that is not
 *                  ignorable according to |is_ignorable|, or
 *               2) null if no such node exists.
 */
function last_child( par )
{
  var res=par.lastChild;
  while (res) {
    if (!is_ignorable(res)) return res;
    res = res.previousSibling;
  }
  return null;
}

/**
 * Version of |firstChild| that skips nodes that are entirely
 * whitespace and comments.
 *
 * @param sib  The reference node.
 * @return     Either:
 *               1) The first child of |sib| that is not
 *                  ignorable according to |is_ignorable|, or
 *               2) null if no such node exists.
 */
function first_child( par )
{
  var res=par.firstChild;
  while (res) {
    if (!is_ignorable(res)) return res;
    res = res.nextSibling;
  }
  return null;
}

/**
 * Version of |data| that doesn't include whitespace at the beginning
 * and end and normalizes all whitespace to a single space.  (Normally
 * |data| is a property of text nodes that gives the text of the node.)
 *
 * @param txt  The text node whose data should be returned
 * @return     A string giving the contents of the text node with
 *             whitespace collapsed.
 */
function data_of( txt )
{
  var data = txt.data;
  // Use ECMA-262 Edition 3 String and RegExp features
  data = data.replace(/[\t\n\r ]+/g, " ");
  if (data.charAt(0) == " ")
    data = data.substring(1, data.length);
  if (data.charAt(data.length - 1) == " ")
    data = data.substring(0, data.length - 1);
  return data;
}







//////////////////////////////////////////////////////////////////////////////////////////
</script>
</HEAD> 
<BODY> 
<div id = 'form' class = 'center'>
<H1>Enter Customer/Order XML File</H1>
<input id = "xmlNameInput" type="text" name="XmlName" value="" />
<br/>
<input type="button" value="Submit" onClick = "passXmlFile()"/>
</div>
<div class = 'center' id = "content"></div>
<noscript>
</BODY> 
</HTML> 